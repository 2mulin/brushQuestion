/********************************************************************************************
 * @author reddragon
 * @date 2021/3/29
 * @brief easy 颠到二进制数
 * 
 * 1，位运算
 * 思路很巧妙, 太难想了, 每次留下n的第 31 - i 位数,赋给ret的第 i 位数
 * 我一开始有思路, 但是还差一点才能写出来, 不熟悉
 * 时间复杂度：O(logN)			空间复杂度: O(1)
 * 
 * 2. 位运算分治
 * 暂时看不懂
 * 时间复杂度: O(1)             空间复杂度: O(1)
 ********************************************************************************************/
#include <iostream>
#include <algorithm>
using namespace std;

uint32_t reverseBits(uint32_t n)
{
    uint32_t ret = 0;
    for(int i = 0; i < 32; ++i)
    {
        ret |= (n & 1) << (31 - i); // 每次只留下一位数, 左移31 - i, 赋给ret
        n >>= 1;// 下一次留下的那位数
    }
    return ret;
}

int main()
{
    cout << reverseBits(43261596) << endl;
    return 0;
}