/********************************************************************************************
 * @author reddragon
 * @date 2020/10/29
 * @brief poj1664 放苹果
 * 1. 递归
 * 看清楚题目的意思，题目说的是盘子任意放多少个苹果，可以不放，只要最后所有的苹果都放进盘子就行了
 * 最开始的思路是：每个盘子放x (0 ~ m)个，下一个盘子就是放0 ~ m-x个,以此写成一个递归，
 * 例子： 7个苹果3个盘子
 * 最后发现行不通，因为要么会有重复的比如：1，5，1 和 5，1，1
 * 要么会漏掉一些答案：3，3，1 和 2，2，3
 * 
 * 最后看老师题解才知道是以当前盘子留空还是不留空为递归下去的
 * 时间复杂度：O(N)          空间复杂度：O(N)
 ********************************************************************************************/
#include <iostream>
#include <vector>
using std::cin;
using std::cout;
using std::endl;
using std::vector;

/********************** 
 * @par 苹果个数
 * @par 盘子个数
 * @return 不同摆放的种数
 *********************/
int foo(int m, int n)
{
    // 苹果摆放完毕，正常
    if(m == 0 && n >= 0)
        return 1;
    // 苹果还有，但是没有盘子了，失败
    if(m > 0 && n <= 0)
        return 0;
    // 分两种情况：留空还是不留空
    // 1.苹果数目 < 盘子数目
    if(m < n)
        return foo(m, m);
    else
    {// 苹果数目 >= 盘子数目
        // 前面是不留空（每个盘子至少放一个苹果），+号后面表示留一个空，然后递归其他情况
        return foo(m - n, n) + foo(m, n - 1);
    }
}

int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        int m,n;
        cin >> m >> n;
        cout << foo(m, n) << endl;
    }
    return 0;
}